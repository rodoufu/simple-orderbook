# simple-orderbook

## Build

The project has a `Makefile` which is able to build the project locally and inside Docker.

To build the project locally use `make build` and use `make run` to execute it.

In order to build the project using docker one may use `make build_docker` and `make run_docker` to execute it inside
the container.

It is also possible to run the unit tests using `make test` and clean the generated binary and image with `make clean`.

## Structure

The service is modeled in basically 2 main interfaces cause ideally in production the service could use 2 microservices
for each symbol, one for the matching engine and another one for the order book.

Splitting it in 2 distinct services decreases the load and the locks for specifics tasks.
Let say there are queries like get top 20 orders on the book or a websocket feeding the clients with market data
information.
In this case having those operations only in the order book decreases the pressure on the matching engine.
It is also easy to scale the order book for as many instances as necessary.

### engine/MatchingEngine

The matching engine is responsible for matching the orders and publishing events to update the order book and any other
service that may need that information.
In the implemented code the matching engine is posting events to its `events` channel, but that could be a topic of a
stream that all the services would be listening to.

It uses internally 2 sorted array of orders.
Adding an order time cost is $O(n)$ where $n$ is the number of orders in the book, and it uses $O(1)$ additional memory.
The worst case happens when an order does not get matched and end up in the bottom of the book, so all the orders need
to be shifted one position.
A possible way to improve that would be using a linked list instead of an array, this way adding an object would not
cost to copy the following ones on position each.
Another option would be to use binary search to find the position of the order but in the end the problem of shifting
all the orders after that one would still remain.

Cancel order time cost is $O(n)$ cause every time it needs to check all the orders in the book, this situation may also
need to shift all the elements like in the case of adding an order.
There is a simple optimization for the case where the order is not in the book by using a hash map to verify that.
This may be useful when a client tries to cancel an order ant it gets filled before the client can update it.

### orderbook/OrderBook

Is responsible for aggregating the events generated by the MatchingEngine and providing information such as `asks`
, `bids`, and could provide real time data to the clients via websocket.

The `asks` and `bids` methods return a channel instead of a list to avoid having to allocate a copy of the whole book
for every request.
A goroutine is created to populate that channel, which is finalized once all the messages are sent or the context gets
cancelled.
